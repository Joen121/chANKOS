# 第四章 基于数字的系统

### 数字的概念

过去，许多科学最终都在试图找到用数字来描述自然系统的方法。

可在本书中，我几乎没有提到数字。然而，本章的目的是调查一系列基于数字的系统，将他们的行为与我们在其他系统中发现的行为相比较。

基于数字的系统在传统科学中如此受欢迎的主要原因在于，为处理这些数字而发展了大量的数学。事实上，有一些基于数字的系统，其行为几乎可以完全用微积分等数学方法进行分析。

当然不可避免的是，当这种完整的分析是可能的时候，最终的行为是相当简单的。

那么基于数字的系统实际上是否会产生复杂的行为呢？纵观科学和数学的绝大多数教科书，人们可能会得出结论，它们不能。但是，我们必须认识到，这些教科书中讨论的系统通常是专门选择适合于完全分析的系统，因此其行为必然非常简单。

事实上，正如我们在本章中将要看到的那样，如果忽略分析的需要，而只是看计算机实验的结果，那么很快就会发现，即使是基于数字的相当简单的系统也会导致高度复杂的行为。

（p115）

但是这种复杂性的起源是什么呢？这与我们在元胞自动机系统中看到的复杂性有什么关系？

有人可能会认为，用数学来研究系统的所有数学都可以很容易地回答这些问题。但事实上，传统的数学似乎导致了更多的困惑，而不是帮助。

一个基本的问题是，数字在传统数学中的处理方式与在计算机和计算机程序中处理的方式有很大不同。从某种意义上说，传统的数学是一个基本的理想化：它假定数字是基本的对象，其唯一的相关属性是它们的大小。但在计算机中，数字不是基本对象。相反，他们必须通过给出一个数字序列明确表示。

用数字表示数字的想法在日常生活中是很熟悉的：实际上，我们写数字的标准方式恰好与以10为基数的数字序列完全相同。基数10意味着每个数字有10个可能的选择：0到9，但正如页面底部的图片所示，可以同样使用其他基础。而在实际的计算机中，例如，基数2几乎总是被使用的。

![](assets/p116.png)
数字3829在各个基底的表现。 最常见的情况是基数10，从右边连续的数字开始，对应于单位，数十，数百等等。 在基数10中，有10个可能的数字：0到9.在其他基数中，可能的数字有不同的数字。 在实际计算机中使用的基数2中，只有两个可能的数字：0和1.在这个基数中，从右边开始的连续数字具有系数1,2,4 = 2 * 2,8 = 2 * 2 * 2等.

（p116）

那么这意味着在计算机中，数字是由0和1的序列表示的，就像元胞自动机这样的系统中的白色和黑色元胞的序列。而数字操作则对应于更新0和1序列的方法。

在传统数学中，数字操作如何影响数字序列的细节通常被认为是无关紧要的。但是我们在本章中会发现，正是通过查看这些细节，我们才能更清楚地看到在基于数字的系统中复杂性如何发展。

在许多情况下，我们发现的行为看起来与前一章中看到的非常相似。事实上，最后，尽管传统数学提出了一些令人困惑的建议，但我们会发现，基于数字的系统的一般行为与我们已经讨论过的简单程序的一般行为非常相似。

### 基本算术

初等算术的操作是如此简单，以至于他们不可能导致任何复杂的行为。但是我们在这一部分会发现，事实上它们可以。

首先，考虑什么是最简单的可能的算术过程：从数字1开始，然后在逐步的每一步中逐渐加1。这个过程的结果是产生连续的数字1,2,3,4,5,6,7,8，这些数字的大小显然是一个非常简单的过程。

但是，如果一个人看起来不是这些整体大小，而是看起来是数字序列，那么所看到的就更加复杂了。事实上，正如下图所示，这些连续的数字序列（二进制形式——译者注）形成了一个显示错综复杂的嵌套结构的模式。

![](assets/p117.png)

（p117）
下面的图片显示了如果在每一步添加1以外的数字会发生什么。 靠近右边缘的部分，每个图案都有所不同。 但总体而言，所有的模式具有完全相同的基本嵌套结构。

![](assets/p118.png)

以1开始，然后在每个步骤中连续添加常数获得的数字的基数2中的数字序列。 所有这些模式最终都有相同的整体嵌套形式。



但是，如果不是加法运算使用乘法运算，那么得到的结果可能会非常不同。 下一页页顶部的第一张图片显示了如果从1开始，然后在每一步继续乘以2会发生什么。

事实证明，如果用数字表示数字作为基数为2的数字序列，则乘以2的操作具有非常简单的效果：它只是将数字序列向左移动一位，在右边添加一个0数字。 结果，连续乘以2得到的整体模式具有非常简单的形式。

（p118）

![](assets/p119.png)
从数字1开始，然后依次乘以因子2和因子3产生的模式。在每种情况下，在每个步骤中获得的数字的数字序列以基数2示出。乘以2仅仅对应于将基数2中的所有数字向左移动一个位置，使得在这种情况下产生的总体模式非常简单。但乘以3会产生更复杂的模式，如上图所示。请注意，在这些图片中，在每个步骤中获得的完整数字分别对应于2和3的连续整数幂。

但是如果在每一步的倍增因子是3而不是2，那么获得的图案是相当不同的，正如第二张图片。事实上，尽管所使用的唯一操作只是简单的乘法运算，但在这种情况下获得的最终模式非常复杂。

下一页的图片显示了系统演进的更多步骤。在一个小规模的，有一些明显的三角形和其他结构，但超出这些模式看起来基本上是随机的。

就像在元胞自动机这样的简单程序中一样，基于数字的简单系统似乎也会产生非常复杂且显然是随机的行为。

但是我们可以想象，我们在下一页的图片中看到的复杂性必定是由于我们正在按照数字序列来查看数字的结果 —— 而且如果我们只是看着数字他们的整体规模的条款。

然而，一些例子会证明事实并非如此。

要开始第一个例子，考虑如果在每一步乘以1.5，会发生什么情况。从1开始，这样得到的连续数是1，3/2=1.5，9/4=2.25，27/8=3.375，81/16=5.0625，243/32=7.59375，729/64=11.390625，……

（p119）

![](assets/p120.png)

3的500步平方，以2为基底显示。一些小规模的结构是可见的，但在更大规模的模式似乎是随机的所有实际目的。 请注意，这里显示的模式已被截断在左边的页面边缘，虽然实际上整个模式继续向左扩展，平均斜率Log [2,3]=1.58。

（p120）

下面的图片显示了这些数字的基数为2的数字序列。位于模式顶部的原始1的正下方和左侧的数字对应于每个连续数字的整数部分（例如3.375中的3 ），而位于右侧的数字对应于小数部分（例如3.375中的0.375）。

![](assets/p121.png)
以2为基底对3/2的连续平方。3/2的乘法可以被认为是乘以3乘以除以2得到的除法。但是除以2只是乘以2的相反，所以在基数2中它简单地将所有数字向右移动一个位置。 整体模式因此是面向页面上显示的模式的移位版本。

不明确地查看完整的数字模式，而是可以考虑找到每个连续数字的小数部分的大小。 这些尺寸绘制在下一页的顶部。 图片也显示出它们在数字水平上也表现出那种复杂性和明显的随机性。

（p121）


![](assets/p122.png)
3/2的连续幂的小数部分的大小。 这些大小是完全独立于什么基地是用来表示数字。 只有点是重要的; 它们之间的阴影和线条只是包含在内，以使绘图更易于阅读。

 刚刚给出的例子涉及具有小数部分的数字。 但事实证明，类似的现象也可以在只涉及整数的系统中找到。

作为第一个例子，考虑用上面乘以3/2的操作的细微变化：如果特定步骤中的数字是偶数（可以被2除尽），那么简单地乘以该数字，得到整数。 但是，如果数字是奇数，那么首先加1，以得到一个偶数，然后乘以3/2。


![](assets/p122_2.png)
从数字1开始的结果，然后应用以下规则：如果特定步骤中的数字是偶数，则乘以3/2; 否则，加1，然后乘以3/2。 这个过程产生一连串的整数，其基数为2的数字序列显示在右边。 上面显示了在每个步骤中获得的最右边的数字。 数字为偶数时为0，奇数时为1，如图所示，数字以表面上随机的方式交替。 事实证明，这里所描述的系统与研究第100页上所示的注册机器时产生的系统密切相关。
这个系统可以用规则表示为：n->If[EvenQ[n],3n/2,3(n+1)/2]，100页的规则是n->If[EvenQ[n],3n/2,(3n+1)/2]。在第一步之后，这些系统给出相同的数字序列，除了整体因子3。

（p122）

此过程始终保证给出一个整数。从1开始，得到的数字的顺序是1,3,6,9,15,24,36,54,81,123,186,279,420,630,945,1419,2130,3195,4794， ...

其中一些数字是偶数，而有些则是奇数。但正如页面底部的结果所示，这些数字的顺序是偶数，奇数似乎是完全随机的。

然而，尽管有这种随机性，获得的数字的总体规模仍然相当规律的增长。但通过稍微改变程序，就可以得到更规律的增长。

作为一个例子，考虑以下程序：如果在特定步骤中获得的数字是偶数，则将该数字乘以5/2;否则，加1，然后乘以1/2。

如果从1开始，那么这个过程在每一步简单地给出1。确实有很多起始数字，程序产生纯粹的重复行为。但正如下图所示，它也可以给出更复杂的行为。

![](assets/p123.png)
应用规则 n->If[EvenQ[n],5n/2,(n+1)/2]，从不同的初始n开始。许多案例中，是纯粹的重复行为。但在一些例子中不是的。

从数字6开始，在连续步骤中获得的数字的大小表现出普遍增加的趋势，但是存在相当大的波动，并且这些波动似乎本质上是随机的。事实上，即使经过一百万步后，获得的数字有48,554（10位数字），仍然没有重复的迹象或任何其他显着的规律性。

（p123）

![](assets/p124.png)
结果遵循与前一页相同的规则，从数值6开始。在右边绘制的是第一千步获得的数字的整体大小。该图是以对数为单位的，所以每个点的高度本质上就是它所代表的数字的数字序列的长度，或左边的行的宽度。

所以，即使只考虑整数的整体大小，仍然有可能在基于数字的系统中变得非常复杂。

但是，虽然在这个层面上复杂性是显而易见的，但通常有必要进入更详细的层面，以便真正了解其发生的原因。事实上，我们在这一部分发现的是，如果我们看一下数字序列，那么就可以看到与像元胞自动机这样的系统产生的复杂模式非常相似的复杂模式。

然而像元胞自动机这样的系统的基本规则通常与基于数字的系统的规则不同。重点是元胞自动机的规则总是局部的：任何特定单元格的新颜色只取决于该单元格及其直接邻居的以前的颜色。但是在基于数字的系统中通常没有这样的地方。

从手上计算得知，即使像加法这样的操作也会导致任意向左传播的数字。事实上，最简单的算术运算具有这样的性质，即在其结果中的特定位置出现的数字可以取决于原来远离它的数字。

（p124）

但是，尽管基本规则中的基本差异如此，但基于数字的系统所产生的整体行为仍然非常类似于例如元胞自动机所看到的。 

因此，就像我们在前一章讨论的各种程序一样，基本规则的细节似乎也不会对可能发生的行为产生重要影响。 

事实上，尽管在其基本规则中缺少局部性，下面几页的图片显示，甚至有可能找到基于数字的系统，这些数字展示了我们在第32页的元胞自动机中看到的局部结构。

![](assets/p125.png)

按照以下规则定义的系统示例：在每个步骤中，取得在该步骤中获得的编号，并以相反的顺序编写其基数2位数，然后将结果编号添加到原始编号中。 对于许多可能的起始号码，获得的行为是非常简单的。 这张照片显示了当人们从数字16开始时会发生什么事情。经过180步后，结果证明所有存活的东西都是一些可以看作是局部结构的物体。

（p125）

![](assets/p126.png)

与前一页相同规则的系统进化的一千步，但是现在从512开始。本地化的结构是可见的，但总体模式似乎从来没有采取过任何一种简单的重复形式。

（p126）

![](assets/p127.png)

从第一百万步开始，面向页面上的模式继续。 图片显示了图案的右边缘; 完整的图案延伸到左侧页面宽度的约700倍。

（p127）

### 递归序列

在前面的章节中，我们看到，通过应用基于简单算术的各种操作，可以获得相当复杂的行为。在本节中，我将展示的是，通过恰当的设置，加减只是某种意义上的唯一操作。

基本思想是考虑一系列数字，其中有一个明确的规则来获得序列中的下一个数字。将每个序列中的第一个数字称为f[1]第二个数字f[2]，以此类推，以便表示数字nth为f[n]。用这个符号，规则的作用是规定如何从序列中之前的数字计算出f[n]来的。

在最简单的情况下，f[n]只取决于它之前f[n-1]序列号。但是也可以建立规则，不仅要依赖于f[n-1]，还要依赖于序列中更早的数字f[n-2]。

下面的表格给出了一些具体规则的结果。在所有的情况下，这些结果都是非常简单的，包括序列的增加是一致的或是以一种纯粹重复的方式波动的。

![](assets/p128.png)
一些简单的递归序列的例子。 每个序列中的第n个元素被表示为f[n]，规则指定如何从前面的元素确定这个元素。 按照这里显示的所有规则，连续的元素要么顺利地增加，要么以纯粹重复的方式波动。 序列（c）是二的幂; （d）是所谓的斐波那契数列，与黄金比例1.618有关。 这里显示的所有类型的规则都会导致序列f[n]用一个简单的形式的幂和来表示。

（p128）

但事实证明，使用稍微复杂的规则，可以获得更复杂的行为。
关键的想法是考虑规则，这些规则考虑的不仅是序列中的固定距离。
而这意味着，不仅仅取决于f[n-1]和f[n-2]这样的数量，而且f[n]的规则也可以取决于数量如f[n-f[n-1]]。

这里有一些微妙之处，因为从抽象的角度来说，没有什么能够保证n-f[n-1]必然是一个正数。
如果不是，那么通过应用规则获得的结果可能涉及无意义的数量，例如f[0]、f[-1]和f[-2]。


![](assets/p129_1.png)
![](assets/p129_2.png)
由不依赖于固定距离的元素的规则生成的序列示例。
大多数这样的规则最终最终会涉及毫无意义的数量，
例如f[0]和f[1]，但是这里显示的特定规则都可以避免这个问题。

（p129）

![](assets/p130.png)
整个前一页的序列增加波动。
在情况（c）和（d）中，波动具有规则的嵌套形式，并且直接与基地2位数字序列相关。
在其他情况下，波动更加复杂，并且在许多方面看起来是随机的。
这里显示的所有规则都以f[1]=f[2]=1开始。

（p130）

对于随机写下的绝大多数规则而言，确实会发生这样的问题。
但是有可能找到他们不知道的规则，前两页的图片展示了我发现的这些规则的一些例子。
在情况（a）和（b）中，行为相当简单。 但在其他情况下，情况要复杂得多。

总体增长稳步增长，但叠加在增幅上的是波动，正如前面一页上的图片所示。

在情况（c）和（d）中，这些波动具有非常规则的嵌套形式。
但在其他情况下，波动在许多方面似乎是随机的。
因此，例如在（f）的情况下，即使经过一百万步之后，正负波动的数量平均出现相等。

但从某种意义上说，前页里最令人惊讶的特征之一是它显示的波动非常剧烈。
有人可能会认为，从这里开始只会有一点变化。
毕竟，在和之间只有0.05％的变化。

但就像我们在前一节看到的那样，事实证明，它的大小似乎并不像其代表性的各个方面那么重要。
事实上，在（c）和（d）的情况下，例如，f [n]的波动和2的基数序列之间存在直接关系。

在情况（d）中，每个波动基本上只是基数2数字序列中出现的1的数目。
并且在情况（c）中，波动由在所有数字小于的数字序列中出现的1的总数决定。

前一页上显示的其他规则没有这种简单的关系。
但总的来说，人们怀疑所有这些规则都可以被认为是像简单的计算机程序那样将一些表示作为他们的输入。

我们在本节中发现的是，即使规则最终只涉及加减，但它们仍然对应于能够产生非常复杂行为的程序。

（译者注：经测试，f、e作为音频信号波形均表现为噪声）
（p131）

### 素数序列

在所有可能的数字序列中，1,2,3,4,5,6,7,8，...大多数可以被其他数字整除——例如6可以被2和3整除。
但是，对于每个数字都不是这样。
因此，例如5和7不能被任何其他数字整除（除了1之外）。
事实上，有两千多年的历史，有一系列所谓的素数不能被其他数字整除，前两个数字是2,3,5,7,11,13,17 ,19,23,29,31,37,...

下面的图片显示了一个简单的规则，通过这个规则可以获得这样的素数。
这个想法是从所有可能的数字开始。然后在第二行删除大于2的所有可被2整除的数字。
在第三行删除可被3整除的数字，依此类推。 随着时间的推移，剩下的数字越来越少。 
但有些数字总是保持不变，而这些数字正是素数。

![](assets/p132.png)
图为产生素数的过滤过程。
首先在第一行开始，所有数字在1到100之间。
然后在第二行，删除大于2的数字，可以被2整除——如灰点所示。
在第三行中，删除大于3的数字，可以被3整除。
如果这个数字永远持续下去，那么一些数字总是保持不变，而这些数字正是素数。
这个过程基本上就是公元前200年已知的Eratosthenes之筛。


考虑到这条规则的简单性，人们可以想象它产生的素数序列也相应简单。
但正如本书其他许多例子一样，事实上并非如此。
事实上，页面上的图表显示了这个序列的各种特征，表明它在很多方面都是非常随机的。

（p132）

![](assets/p133.png)
素数序列的特征。 尽管在生成素数的前一页上的规则很简单，但是获得的素数的实际顺序在许多方面似乎是非常随机的。

（p133）

我在本书中已经展示的复杂性的例子几乎都是全新的。
但前几百个素数无疑在古代是知道的，而且它的分布至少有一定的复杂性。

然而，如果没有我在本书中发展的整个知识结构，这个观察的意义——例如它与自然现象的潜在联系——都没有被意识到。
尽管在数百年的历史中对于素数序列进行了大量的数学工作，但几乎毫无例外，它一直关注的不是复杂性的基本问题，而是试图寻找特定类型的规律。

事实证明，事实上很少发现规律性，并且通常已经建立的结果往往只支持序列具有许多随机性特征的想法。
所以，作为一个例子，从前一页的图片可以看出，（c），（d）和（e）总是在系统上保持在轴上方。
但事实上，经过相当大的努力，已经证明它们在某种意义上是更随机的——并且最终跨越轴线无限多次，并且确实上下移动任意距离。

在每个例子中都可以看到相当程度的复杂性。

如果我们从每个数字的整体大小来看，而不是根据它的数字序列或可能的因子集，就可以理解其中的一些复杂性。
但在大多数情况下——尽管经过数百年的数论工作，往往相当复杂。

事实上，唯一合理的结论似乎就像在本书的许多其他系统中一样，这样的数字序列表现出复杂性，
以某种方式出现作为序列生成规则的基本结果。

（p134）

![](assets/p133.png)
基于各种简单的数字属性的序列。数论的大量工作仅仅成功地建立了这些的一些性质。
例如，（d）永远不会达到零，曲线（c）只对形式为4^r(8s+7)的数字达到零。
序列（b）在所谓的完美数字处为零。
即使是完美的数字总是有一个已知的形式，但是否存在任何奇数完美数字是一个在两千多年内仍未解决的问题。
序列（e）从未达到零的说法被称为哥德巴赫猜想（Goldbach's Conjecture）。它是在1742年制作的，但没有找到任何证明或反例。

（p135）

### 数学常量

最后几节表明，可以根据可能出现极大复杂性的数字设置各种系统。
事实证明，初等数学中的一些众所周知的事实已经暗示了这种复杂性的可能性。

有争议的事实涉及数字中的数字序列，如（pi）。
一个非常粗略的近似值是3.14。
更精确的近似值是3.14159265358979323846264338327950288。

但是这个数字序列如何继续？

有人可能会认为，在某种程度上，它必须非常简单和规律。
对于值π的定义是简单定义为任何圆的周长与其直径的比值。

但事实证明，即使这个定义很简单，π的数字序列根本就不简单。
面向页面显示序列中的前4000个数字，通常情况下是基数10，基数为2.下图显示了序列中前20000个数字的图形表示。

以2为底数的前20,000位数字的图形表示。
每次数字为1时绘制的曲线上升，每次为0时下降。
复杂性非常明显。
如果曲线进一步继续下去，它会在轴上花费更多的时间，并且所看到的任何方面都没有提供任何证据表明数字序列是完全随机的。

（p136）


![](assets/p137.png)

>π在基数10和2中的前4000个数字。尽管π的简单定义是圆的直径与圆的直径的比率，但其数字序列足够复杂，以至于实际上看起来是随机的。

（p137）

没有任何明显的规律。实际上，迄今为止计算的π的所有数字都超过了2000亿，仍然没有发现任何类型的重要规律性。
尽管其定义很简单，但实际上的数字序列完全是随机的。

但其他数字呢？π是一种特殊情况，还是说其他常见的数字常量都具有复杂的数字序列？
有些数字的数字序列的长度有限。因此，例如，基数10中的数字序列是0.375。
（严格来说，数字序列是0.3750000000 ...，但0不会影响数字的值，因此通常会被省略）

但是，很容易找到数字序列不会终止的数字。
因此，例如，基数10的确切值是0.3333333333333 ...，其中3是永远重复的。
同样，是0.142857142857142857142857142857 ...，现在数字块142857永远重复。
下表给出了通过分成整数对得到的几个有理数的数字序列。
在所有情况下，我们看到的是这些数字的数字序列具有简单的重复形式。
而事实证明，所有有理数的数字序列最终都会重复。

![](assets/p138.png)

对于各种有理数的数字序列，以十进制（上）和二进制（下）两种方式给出。
对于形式为p / q的数字，序列总是以最多q - 1步骤的周期重复。

（p138）

通过查看执行工作流程的细节，我们可以理解为什么是这样的。
下面的图片显示了用于计算有理数p / q的基2位数序列的特定方法中的连续步骤

![](assets/p139.png)

>计算各种有理数的连续步骤。
在每种情况下，右边的列显示数字中基数2的数字序列，而左边的数字框显示计算中每个步骤的余数。
(译注：从上往下看。如1/2的序列，r起初为1——左黑色方格，在除尽后为0——白色方格并且不再变化)

该方法基本上是标准的长除法，虽然在基数2中比在基数10的通常情况下要简单一些。
想法是有一个数字r，基本上跟踪分区中每个步骤的余数。
一开始设置r等于p。 然后在每一步中，比较2r和q的值。
如果2r小于q，则在该步骤生成的数字为0，并将r替换为2r。
否则，r被替换2r-q。 通过这个程序，r值总是小于q。
结果，获得的数字序列总是在每q-1个步骤中重复。

但事实证明，有理数是非常罕见的，具有这样简单的数字序列。
事实上，如果以平方根为例，这个故事就完全不同了

完美的平方根例如4=2*2和9=3*3，专门设置为具有整数的平方根。
但是当下一页顶部的表格显示时，其他平方根具有更复杂的数字序列。
事实上，就我们所知，除了完美平方根以外的所有整数都有平方根，其数字序列完全是随机的。

（p139）

![](assets/p139.png)

>对于各种平方根的数字序列，以十进制（上）和二进制（下）两种方式给出。
尽管定义很简单，但所有这些序列似乎在实际上都可当做是随机的。


这个程序只比上面讨论的划分要复杂一点。
它涉及两个数字r和s，它们分别被初始设置为n和0。
在每一步中，它比较和s的值，如果r大于s，则将r和s分别替换为4(r-s-1)和2(s+2);否则替换为4r和2s。
然后，结果发现在二进制形式下的数字s完全对应于每个步骤产生一位新数字的√n。

如图所示，该程序的结果表现出相当大的复杂性。
事实上，就像我们在本书中讨论过的其他很多例子一样，生成平方根的过程是基于简单的规则，但是却产生了非常复杂的行为。

（p140）

![](assets/p141.png)

>一个产生平方根的过程。包括两个数字r和s。
为了找到√n，开始设置r=n，s=0，每一步运用规则：
{r,s}->If[r>s,{4(r-s-1),2(s+2)},{4r,2s}}]。
结果是基数2中的数字s与√n的数字结果完全一致。
请注意，如果n不在1和4之间，则在开始此过程之前，必须乘以或除以4的适当幂。


